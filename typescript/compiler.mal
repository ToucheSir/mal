(load-file "interpreter.mal")
(def! with-env
  (fn* [func env]
       (fn* [arg]
            (func arg env))))


(def! KW-PREFIX "_kw_")

(def! OUTPUT (fn* [source]
                (if (sequential? source)
                  (apply str (map OUTPUT source))
                  (print (str source)))))

(def! emit-keyword (fn* [kw env]
                        (EMIT (str KW-PREFIX kw) env)))

(def! emit-map (fn* [m env]
                    (concat ["hashmap("]
                            (interpose ", " (map (with-env EMIT env)
                                                 (apply concat (zip2 (keys m) (vals m)))))
                            [")"])))

(def! zip2 (fn* [seqA seqB]
                (if (or (empty? seqA) (empty? seqB))
                  (list)
                  (cons [(first seqA) (first seqB)] (zip2 (rest seqA) (rest seqB))))))

(def! emit-bindings (fn* [bindings env]
                         (if (>= (count bindings) 2)
                           (cons (concat ["var " (first bindings) "="]
                                         (EMIT (nth bindings 1) env)
                                         ["\n"])
                                 (emit-bindings (rest (rest bindings)) env))
                           (list))))

(def! emit-quasiquote (fn* [form env]
                           (do (println "form=" form)
                               (if (do (not (is-pair form)))
                                 (list 'quote form)
                                 (cons 'concat (map (fn* [elem]
                                                         (cond
                                                           (not (is-pair elem)) (list 'list (list 'quote elem)) ; (list (quote elem))
                                                           (= 'unquote (first elem)) (list 'list (nth elem 1)) ; (list elem)
                                                           (= 'splice-unquote (first elem)) (nth elem 1)
                                                           "else" (list 'list (list 'quote elem)))) ; (list (quote elem))
                                                    form))))))

(def! emit-try-catch (fn* [ast env]
                          (concat ["try {\n"
                                   (EMIT (first ast) env)]
                                  (if (= 'catch* (first (nth ast 1)))
                                    ["\n} catch (" (EMIT (nth (nth ast 1) 1) env) ") {\n"
                                     (EMIT (nth (nth ast 1) 2) env)])
                                  ["\n}"])))

(def! emit-do-statements (fn* [ast env]
                              (if (empty? (rest ast))
                                ["return (" (EMIT (first ast) env) ")\n"]
                                [(cons [(EMIT (first ast) env) "\n"]
                                       (emit-do-statements (rest ast) env))])))

(def! emit-function-decl (fn* [params body env]
                              (concat ["(("]
                                      (interpose ", " (map (with-env EMIT env) params))
                                      [") => {\n"
                                       (EMIT body env)
                                       "\n})"])))




(def! emit-list (fn* [l env] (let* [sym (first l)
                                    args (rest l)]
                               (cond
                                 (= 'def! sym) (concat ["var " (first args) "="]
                                                       (EMIT (nth args 1) env))
                                 (= 'let* sym) (let* [defs (first args)
                                                      ret (EMIT (nth args 1) env)]
                                                 (concat ["(() => {\n"]
                                                         (emit-bindings defs env)
                                                         ["return (" ret ")\n"]
                                                         ["}())"]))
                                 (= 'quote sym) (if (list? (first args))
                                                  (EMIT (cons 'list (first args)) env)
                                                  (EMIT (first args) env))
                                 (= 'quasiquote sym)
                                 (let* [qq (emit-quasiquote (first args) env)]
                                   (EMIT qq env))
                                 ;; macros are currently only evaluated at compile time
                                 (= 'defmacro! sym) (do (EVAL l env) (list))
                                 ;; macro expansion is currently compile time only
                                 (= 'macroexpand sym) (EMIT (EVAL l env) env)
                                 (= 'try* sym) (emit-try-catch (rest l) env)
                                 ;; TODO is it worth being devious and emitting
                                 ;; a comma expression instead?
                                 (= 'do sym) (concat ["(() => {\n"]
                                                     (emit-do-statements (rest l) env)
                                                     ["}())"])
                                 (= 'if sym) ["(" (EMIT (nth l 1) env)
                                              " ? " (EMIT (nth l 2) env)
                                              " : " (EMIT (if (> (count l) 3)
                                                            (nth l 3)
                                                            NIL)
                                                          env)
                                              ")"]
                                 (= 'fn* sym) (emit-function-decl (nth l 1) (nth l 2) env)
                                 "else" (concat [(str (EMIT sym env) "(")]
                                                (interpose ", " (map (with-env EMIT env) args))
                                                [")"])))))

(def! emit-vector (fn* [v env] (concat ["vector("]
                                   (interpose ", " (map (with-env EMIT env) v))
                                   [")"])))

(def! EMIT (fn* [ast env]
                (cond
                  (list? ast) (emit-list ast env)
                  (vector? ast) (emit-vector ast env)
                  (map? ast) (emit-map ast env)
                  (keyword? ast) (emit-keyword ast env)
                  "else" (pr-str ast))))

(def! preprocess (fn* [ast]
                    ast))

(def! gencode (fn* [ast env]
                   (do (OUTPUT (EMIT ast env)) (println))))

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
               (PRINT (EVAL (READ strng) repl-env))))

;; compilation
(def! compile-js (fn* [string]
                   (gencode (preprocess (READ string) repl-env) repl-env)))


;; core.mal: defined directly using mal
(map (fn* [data] (env-set repl-env (nth data 0) (nth data 1))) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep (str "(def! *host-language* \"" *host-language* "-mal\")"))
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \")\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")
(rep "(defmacro! or (fn* (& xs) (if (empty? xs) nil (if (= 1 (count xs)) (first xs) `(let* (or_FIXME ~(first xs)) (if or_FIXME or_FIXME (or ~@(rest xs))))))))")

;; repl loop
(def! repl-loop (fn* []
                     (let* [line (readline "mal-user> ")]
                       (if line
                         (do
                           (if (not (= "" line))
                             (try*
                               (do (println (rep line))
                                   (println)
                                   (println (compile-js line)))
                               (catch* exc
                                       (println "Uncaught exception:" exc))))
                           (repl-loop))))))

(def! -main (fn* [& args]
                 (if (> (count args) 0)
                   (do
                     (compile-js (first args))
                     (rep (str "(load-file \"" (first args) "\")")))
                   (do
                     (rep "(println (str \"Mal [\" *host-language* \"]\"))")
                     (repl-loop)))))
(apply -main *ARGV*)
