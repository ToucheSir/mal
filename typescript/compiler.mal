(load-file "interpreter.mal")
(def! with-env
  (fn* [func env]
       (fn* [arg]
            (func arg env))))


(def! KW-PREFIX "_kw_")

(def! OUTPUT (fn* [source]
                (if (sequential? source)
                  (apply str (map OUTPUT source))
                  (print (str source)))))

(def! emit-keyword (fn* [kw env]
                        (EMIT (str KW-PREFIX kw) env)))

(def! emit-map (fn* [m env]
                    (concat ["hashmap("]
                            (interpose ", " (map (with-env EMIT env)
                                                 (apply concat (zip2 (keys m) (vals m)))))
                            [")"])))

(def! zip2 (fn* [seqA seqB]
                (if (or (empty? seqA) (empty? seqB))
                  (list)
                  (cons [(first seqA) (first seqB)] (zip2 (rest seqA) (rest seqB))))))

(def! emit-bindings (fn* [bindings env]
                         (if (>= (count bindings) 2)
                           (cons (concat ["var " (first bindings) "="]
                                         (EMIT (nth bindings 1) env)
                                         ["\n"])
                                 (emit-bindings (rest (rest bindings)) env))
                           (list))))

(def! emit-quasiquote (fn* [form env]
                           (do (println "form=" form)
                               (if (do (not (is-pair form)))
                                 (list 'quote form)
                                 (cons 'concat (map (fn* [elem]
                                                         (cond
                                                           (not (is-pair elem))
                                                           (list 'list (list 'quote elem)) ; (list (quote elem))
                                                           ;
                                                           (= 'unquote (first elem))
                                                           (list 'list (nth elem 1)) ; (list elem)
                                                           ;
                                                           (= 'splice-unquote (first elem))
                                                           (nth elem 1)
                                                           ;
                                                           ;
                                                           "else"
                                                           (list 'list (list 'quote elem)))) ; (list (quote elem))
                                                    form))))))


(def! emit-list (fn* [l env] (let* [sym (first l)
                                    args (rest l)]
                               (cond
                                 (= 'def! sym) (concat ["var " (first args) "="]
                                                       (EMIT (nth args 1) env))
                                 (= 'let* sym) (let* [defs (first args)
                                                      ret (EMIT (nth args 1) env)]
                                                 (concat ["(() => {\n"]
                                                         (emit-bindings defs env)
                                                         ["return (" ret ")\n"]
                                                         ["}())"]))
                                 (= 'quote sym) (if (list? (first args))
                                                  (EMIT (cons 'list (first args)) env)
                                                  (EMIT (first args) env))
                                 (= 'quasiquote sym) (do (println "qq=" (QUASIQUOTE (first args)))
                                                         (let* [sss (emit-quasiquote (first args) env)]
                                                           (do (println "f=" (first args) "emit=" sss)
                                                               (EMIT sss env))))
                                 (= 'defmacro! sym)
                                 (do (EVAL l env) (list))

                                 (= 'macroexpand sym)
                                 (EMIT (EVAL l env) env)

                                 "else" (concat [(str (EMIT sym env) "(")]
                                                (interpose ", " (map (with-env EMIT env) args))
                                                [")"])))))

(def! emit-vector (fn* [v env] (concat ["vector("]
                                   (interpose ", " (map (with-env EMIT env) v))
                                   [")"])))

(def! EMIT (fn* [ast env]
                (cond
                  (list? ast) (emit-list ast env)
                  (vector? ast) (emit-vector ast env)
                  (map? ast) (emit-map ast env)
                  (keyword? ast) (emit-keyword ast env)
                  "else" (pr-str ast))))

(def! preprocess (fn* [ast]
                    ast))

(def! gencode (fn* [ast env]
                   (do (OUTPUT (EMIT ast env)) (println))))

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
               (PRINT (EVAL (READ strng) repl-env))))

;; compilation
(def! compile-js (fn* [string]
                   (gencode (preprocess (READ string) repl-env) repl-env)))


;; core.mal: defined directly using mal
(map (fn* [data] (env-set repl-env (nth data 0) (nth data 1))) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep (str "(def! *host-language* \"" *host-language* "-mal\")"))
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \")\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")
(rep "(defmacro! or (fn* (& xs) (if (empty? xs) nil (if (= 1 (count xs)) (first xs) `(let* (or_FIXME ~(first xs)) (if or_FIXME or_FIXME (or ~@(rest xs))))))))")

;; repl loop
(def! repl-loop (fn* []
                     (let* [line (readline "mal-user> ")]
                       (if line
                         (do
                           (if (not (= "" line))
                             (try*
                               (do (println (rep line))
                                   (println)
                                   (println (compile-js line)))
                               (catch* exc
                                       (println "Uncaught exception:" exc))))
                           (repl-loop))))))

(def! -main (fn* [& args]
                 (if (> (count args) 0)
                   (do
                     (compile-js (first args))
                     (rep (str "(load-file \"" (first args) "\")")))
                   (do
                     (rep "(println (str \"Mal [\" *host-language* \"]\"))")
                     (repl-loop)))))
(apply -main *ARGV*)
(apply -main *ARGV*
                             (cond
                               (= 'cons (first form))
                               (cons (emit-quasiquote (first rst) env) (emit-quasiquote (rest rst) env))

                               (= 'concat (first form))
                               (concat (emit-quasiquote (first rst) env) (emit-quasiquote (rest rst) env))

                               ;(and (is-pair (first form)) (= 'quote (first (first form))))
                               ;(EMIT (first form) env)

                               "else"
                               (EMIT (first form) env)))

(def! emit-list (fn* [l env] (let* [sym (first l)
                                    args (rest l)]
                               (cond
                                 (= 'def! sym) (concat ["var " (first args) "="]
                                                       (EMIT (nth args 1) env))
                                 (= 'let* sym) (let* [defs (first args)
                                                      ret (EMIT (nth args 1) env)]
                                                 (concat ["(() => {\n"]
                                                         (emit-bindings defs env)
                                                         ["return (" ret ")\n"]
                                                         ["}())"]))
                                 (= 'quote sym) (if (list? (first args))
                                                  (EMIT (cons 'list (first args)) env)
                                                  (EMIT (first args) env))
                                 (= 'quasiquote sym) (do (println "qq=" (QUASIQUOTE (first args))
                                                                  (let* [sss (emit-quasiquote (QUASIQUOTE (first args)) env)]
                                                                    (do (println "f=" (first args) "emit=" sss)
                                                                        sss))))
                                 "else" (concat [(str (EMIT sym env) "(")]
                                                (interpose ", " (map (with-env EMIT env) args))
                                                [")"])))))

(def! emit-vector (fn* [v env] (concat ["vector("]
                                   (interpose ", " (map (with-env EMIT env) v))
                                   [")"])))

(def! EMIT (fn* [ast env]
                (cond
                  (list? ast) (emit-list ast env)
                  (vector? ast) (emit-vector ast env)
                  (map? ast) (emit-map ast env)
                  (keyword? ast) (emit-keyword ast env)
                  "else" (pr-str ast))))

(def! preprocess (fn* [ast]
                    ast))

(def! gencode (fn* [ast env]
                   (do (OUTPUT (EMIT ast env)) (println))))

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
               (PRINT (EVAL (READ strng) repl-env))))

;; compilation
(def! compile-js (fn* [string]
                   (gencode (preprocess (READ string) repl-env))))


;; core.mal: defined directly using mal
(map (fn* [data] (env-set repl-env (nth data 0) (nth data 1))) core_ns)
(env-set repl-env 'eval (fn* [ast] (EVAL ast repl-env)))
(env-set repl-env '*ARGV* (rest *ARGV*))

;; core.mal: defined using the new language itself
(rep (str "(def! *host-language* \"" *host-language* "-mal\")"))
(rep "(def! not (fn* [a] (if a false true)))")
(rep "(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \")\")))))")
(rep "(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))")
(rep "(defmacro! or (fn* (& xs) (if (empty? xs) nil (if (= 1 (count xs)) (first xs) `(let* (or_FIXME ~(first xs)) (if or_FIXME or_FIXME (or ~@(rest xs))))))))")

;; repl loop
(def! repl-loop (fn* []
                     (let* [line (readline "mal-user> ")]
                       (if line
                         (do
                           (if (not (= "" line))
                             (try*
                               (do (println (rep line))
                                   (println)
                                   (println (compile-js line)))
                               (catch* exc
                                       (println "Uncaught exception:" exc))))
                           (repl-loop))))))

(def! -main (fn* [& args]
                 (if (> (count args) 0)
                   (do
                     (compile-js (first args))
                     (rep (str "(load-file \"" (first args) "\")")))
                   (do
                     (rep "(println (str \"Mal [\" *host-language* \"]\"))")
                     (repl-loop)))))
(apply -main *ARGV*)
(apply -main *ARGV*
                             (EMIT form env)
                             (let* [rst (rest form)]
                               (cond
                                 (= 'cons (first form))
                                 (cons (emit-quasiquote (first rst) env) (emit-quasiquote (rest rst) env))
                                 ;
                                 (= 'concat (first form))
                                 (concat (emit-quasiquote (first rst) env) (emit-quasiquote (rest rst) env))
                                 ;
                                 ;(and (is-pair (first form)) (= 'quote (first (first form))))
                                 ;(EMIT (first form) env)
                                 ;
                                 "else"
                                 (EMIT (first form) env))))




(def! emit-list (fn* [l env] (let* [sym (first l)
                                    args (rest l)]
                               (cond
                                 (= 'def! sym) (concat ["var " (first args) "="]
                                                       (EMIT (nth args 1) env))
                                 (= 'let* sym) (let* [defs (first args)
                                                      ret (EMIT (nth args 1) env)]
                                                 (concat ["(() => {\n"]
                                                         (emit-bindings defs env)
                                                         ["return (" ret ")\n"]
                                                         ["}())"]))
                                 (= 'quote sym) (if (list? (first args))
                                                  (EMIT (cons 'list (first args)) env)
                                                  (EMIT (first args) env))
                                 (= 'quasiquote sym) (do (println "qq=" (QUASIQUOTE (first args))
                                                                  (let* [sss (emit-quasiquote (QUASIQUOTE (first args)) env)]
                                                                    (do (println "f=" (first args) "emit=" sss)
                                                                        sss))))
                                 "else" (concat [(str (EMIT sym env) "(")]
                                                (interpose ", " (map (with-env EMIT env) args))
                                                [")"])))))

(def! emit-vector (fn* [v env] (concat ["vector("]
                                   (interpose ", " (map (with-env EMIT env) v))
                                   [")"])))

(def! EMIT (fn* [ast env]
                (cond
                  (list? ast) (emit-list ast env)
                  (vector? ast) (emit-vector ast env)
                  (map? ast) (emit-map ast env)
                  (keyword? ast) (emit-keyword ast env)
                  "else" (pr-str ast))))

(def! preprocess (fn* [ast]
                    ast))

(def! gencode (fn* [ast env]
                   (do (OUTPUT (EMIT ast env)) (println))))

;; repl
(def! repl-env (new-env))
(def! rep (fn* [strng]
               (PRINT (EVAL (READ strng) repl-env))))

;; compilation
(def! compile-js (fn* [string]
                   (gencode (preprocess (READ string) repl-env))))


0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
